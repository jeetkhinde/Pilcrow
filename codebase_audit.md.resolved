# Pilcrow Codebase Audit

Full scan of 8 Rust modules, 9 JS files, [build.rs](file:///Users/jagjeet/Development/Pilcrow/build.rs), and tests.

---

## üêõ Bugs

### B1. [navigator.js](file:///Users/jagjeet/Development/Pilcrow/silcrow/navigator.js) ‚Äî Retarget mutates `options` but uses old `targetEl`

[navigator.js:228-231](file:///Users/jagjeet/Development/Pilcrow/silcrow/navigator.js#L228-L231)

```javascript
const retarget = response.headers.get("silcrow-retarget");
if (retarget) {
  const newTarget = document.querySelector(retarget);
  if (newTarget) options.target = newTarget; // mutates options
}
```

The swap still uses `targetEl` (captured at line 151), so `silcrow-retarget` sets `options.target` but never updates the `targetEl` variable used for the actual DOM swap, loading state, side-effects, and events. The retarget header has **no effect**.

**Fix:** Add `targetEl = newTarget;` after the assignment.

---

### B2. [navigator.js](file:///Users/jagjeet/Development/Pilcrow/silcrow/navigator.js) ‚Äî Blank line 249 looks like a deleted statement

[navigator.js:249](file:///Users/jagjeet/Development/Pilcrow/silcrow/navigator.js#L249)

```javascript
      sideEffects = { ... };

   

      text = await response.text();
```

There's a suspicious empty block (3+ blank spaces) between the side-effects capture and `response.text()`. Likely a deleted line that left behind whitespace ‚Äî harmless but should be cleaned up.

---

### B3. [navigator.js](file:///Users/jagjeet/Development/Pilcrow/silcrow/navigator.js) ‚Äî AbortError handler misidentifies timeout vs abort

[navigator.js:354-371](file:///Users/jagjeet/Development/Pilcrow/silcrow/navigator.js#L354-L371)

When a request is aborted because you navigated to the same target (line 164-165), `controller.signal.aborted` is true but it's not a timeout. The catch block at line 355-371 would fire the `TimeoutError` event and call `errorHandler` for a normal abort. Both paths (user-abort and timeout) land in the same block.

**Fix:** Use a flag like `let timedOut = false;` set in the `setTimeout` callback, then discriminate abort vs timeout using that flag.

---

### B4. [extract.rs](file:///Users/jagjeet/Development/Pilcrow/src/extract.rs) ‚Äî `*/*` double-counts for both html and json q-values

[extract.rs:59-64](file:///Users/jagjeet/Development/Pilcrow/src/extract.rs#L59-L64)

```rust
if media_type == "text/html" || media_type == "*/*" {
    max_html_q = max_html_q.max(q);
}
if media_type == "application/json" || media_type == "*/*" {
    max_json_q = max_json_q.max(q);
}
```

When a browser sends `*/*` (which all browsers do), both html and json get the same q-value, so `accepts_html` always wins (line 69: `max_html_q >= max_json_q`). This means an `Accept: */*, application/json` header from an API client would still pick HTML because `*/*` inflates the HTML score equally. The logic works for Silcrow.js requests (which send explicit accept types) but could surprise third-party API consumers.

---

### B5. [response.rs](file:///Users/jagjeet/Development/Pilcrow/src/response.rs) ‚Äî Stale comment on line 65

[response.rs:65](file:///Users/jagjeet/Development/Pilcrow/src/response.rs#L65)

```rust
// In src/response.rs, update the ResponseExt trait:
```

This reads like an instruction from a plan document, not a code comment. Should be removed.

---

## üîÅ DRY Violations

### D1. URL sanitization duplicated between [safety.js](file:///Users/jagjeet/Development/Pilcrow/silcrow/safety.js) and [patcher.js](file:///Users/jagjeet/Development/Pilcrow/silcrow/patcher.js)

The following logic is nearly identical in both files:

| [safety.js](file:///Users/jagjeet/Development/Pilcrow/silcrow/safety.js) | [patcher.js](file:///Users/jagjeet/Development/Pilcrow/silcrow/patcher.js) |
|---|---|
| `SAFE_PROTOCOLS` | `SAFE_URL_PROTOCOLS` |
| `SAFE_DATA_IMAGE_RE` | `PATCH_SAFE_DATA_IMAGE_RE` |
| `URL_ATTRS` | `URL_PROPS` |
| [hasSafeProtocol()](file:///Users/jagjeet/Development/Pilcrow/silcrow/safety.js#54-72) | [hasSafeBoundProtocol()](file:///Users/jagjeet/Development/Pilcrow/silcrow/patcher.js#51-69) |
| [hasSafeSrcSet()](file:///Users/jagjeet/Development/Pilcrow/silcrow/safety.js#73-86) | [hasSafeBoundSrcSet()](file:///Users/jagjeet/Development/Pilcrow/silcrow/patcher.js#70-83) |

These are essentially the same sets and functions with different variable names. They could be unified into a shared module (e.g., a `sanitize-url.js` partial loaded first) so there's a single source of truth for URL safety rules.

---

### D2. [SseRoute](file:///Users/jagjeet/Development/Pilcrow/src/sse.rs#20-21) and [WsRoute](file:///Users/jagjeet/Development/Pilcrow/src/ws.rs#20-21) are identical structs

[sse.rs:19-43](file:///Users/jagjeet/Development/Pilcrow/src/sse.rs#L19-L43) vs [ws.rs:19-43](file:///Users/jagjeet/Development/Pilcrow/src/ws.rs#L19-L43)

Both are:
```rust
pub struct XRoute(&'static str);
impl XRoute { pub const fn new/path }
impl Deref for XRoute { ... }
impl AsRef<str> for XRoute { ... }
```

Consider a generic [Route](file:///Users/jagjeet/Development/Pilcrow/src/ws.rs#20-21) newtype or a macro like `define_route!(SseRoute)` / `define_route!(WsRoute)` to eliminate the copy-paste.

---

### D3. Serialization fallback pattern repeated 3x in [sse.rs](file:///Users/jagjeet/Development/Pilcrow/src/sse.rs) / [ws.rs](file:///Users/jagjeet/Development/Pilcrow/src/ws.rs)

[sse.rs:74-77](file:///Users/jagjeet/Development/Pilcrow/src/sse.rs#L74-L77), [ws.rs:93-96](file:///Users/jagjeet/Development/Pilcrow/src/ws.rs#L93-L96), [ws.rs:145-148](file:///Users/jagjeet/Development/Pilcrow/src/ws.rs#L145-L148)

```rust
let value = serde_json::to_value(data).unwrap_or_else(|e| {
    tracing::warn!("...: {e}");
    serde_json::Value::Null
});
```

This pattern appears 3 times. A helper like `fn serialize_or_null(data, context) -> Value` would DRY this up.

---

### D4. `respond!` macro ‚Äî 11 arms with repeated boilerplate

[macros.rs](file:///Users/jagjeet/Development/Pilcrow/src/macros.rs)

The macro has 11 near-identical arms that repeat `Ok::<_, axum::response::Response>(axum::response::IntoResponse::into_response(...))`. Each arm differs only in whether it has a toast, whether JSON is raw, and whether it's single-arm vs dual-arm. An internal helper macro could collapse this significantly.

---

## üò§ Code Smells

### S1. `navigator.js:navigate()` is 90+ lines

[navigator.js:140-391](file:///Users/jagjeet/Development/Pilcrow/silcrow/navigator.js#L140-L391) ‚Äî this function handles fetching, caching, retargeting, side-effects, history, swap, toast processing, error handling, and loading states. It would benefit from being split into smaller helpers (e.g., `buildFetchOptions`, `processResponse`, `executeSwap`, etc.).

---

### S2. [patcher.js](file:///Users/jagjeet/Development/Pilcrow/silcrow/patcher.js) ‚Äî [registerSubtreeBindings](file:///Users/jagjeet/Development/Pilcrow/silcrow/patcher.js#167-176) re-parses what [registerBinding](file:///Users/jagjeet/Development/Pilcrow/silcrow/patcher.js#149-166) already checks

[patcher.js:167-175](file:///Users/jagjeet/Development/Pilcrow/silcrow/patcher.js#L167-L175) calls [scanBindableNodes](file:///Users/jagjeet/Development/Pilcrow/silcrow/patcher.js#138-148) ‚Üí iterates ‚Üí calls [parseBind](file:///Users/jagjeet/Development/Pilcrow/silcrow/patcher.js#13-21) to check `startsWith('.')` ‚Üí then calls [registerBinding](file:///Users/jagjeet/Development/Pilcrow/silcrow/patcher.js#149-166) which calls [parseBind](file:///Users/jagjeet/Development/Pilcrow/silcrow/patcher.js#13-21) again. Each binding is parsed twice.

---

### S3. [BaseResponse](file:///Users/jagjeet/Development/Pilcrow/src/response.rs#22-27) clones `CookieJar` on every response

[response.rs:36](file:///Users/jagjeet/Development/Pilcrow/src/response.rs#L36)

```rust
let mut final_jar = self.cookies.clone();
```

This clones the jar even when there are no toasts (the [if](file:///Users/jagjeet/Development/Pilcrow/tests/macro_usage.rs#154-169) below only conditionally adds cookies). Consider cloning only when toasts are present, or using `&self.cookies` when no mutation is needed.

---

### S4. Global mutable state in JS

[navigator.js](file:///Users/jagjeet/Development/Pilcrow/silcrow/navigator.js) uses module-level `let routeHandler = null;` and `let errorHandler = null;`. [toasts.js](file:///Users/jagjeet/Development/Pilcrow/silcrow/toasts.js) uses `let toastHandler = null;`. These are effectively global singletons. Fine for a single-page app runtime, but makes testing harder and prevents multiple Silcrow instances on a page.

---

## üí° Improvements

### I1. [build.rs](file:///Users/jagjeet/Development/Pilcrow/build.rs) ‚Äî CRC-32 is a weak fingerprint

[build.rs:44-46](file:///Users/jagjeet/Development/Pilcrow/build.rs#L44-L46) ‚Äî CRC-32 produces an 8-character hex hash. For cache-busting purposes this is fine, but a truncated SHA-256 (e.g., first 8 hex digits) would give better collision resistance at no extra build cost. The `sha2` crate is widely available.

---

### I2. [with_header](file:///Users/jagjeet/Development/Pilcrow/src/response.rs#70-76) key could also be `impl Into<HeaderName>`

Currently:
```rust
fn with_header(mut self, key: &'static str, value: impl Into<String>) -> Self
```

Using `impl IntoHeaderName` (or `HeaderName`) for `key` would let callers pass dynamically-constructed header names without the `'static` constraint. Low priority since custom headers usually are static.

---

### I3. `WsRecvError` could derive `Clone`

[ws.rs:161-169](file:///Users/jagjeet/Development/Pilcrow/src/ws.rs#L161-L169) ‚Äî `WsRecvError::NonText` and `Closed` are trivially cloneable, and `serde_json::Error` supports `Clone`. Deriving `Clone` would make it easier to propagate errors in retry logic.

---

### I4. [navigator.js](file:///Users/jagjeet/Development/Pilcrow/silcrow/navigator.js) ‚Äî `Silcrow.go()` doesn't support `skipHistory`

[index.js:83-92](file:///Users/jagjeet/Development/Pilcrow/silcrow/index.js#L83-L92) ‚Äî The `Silcrow.go()` API doesn't forward `skipHistory` from the options object to [navigate()](file:///Users/jagjeet/Development/Pilcrow/silcrow/navigator.js#139-392), even though the underlying function supports it. Users have no programmatic way to navigate without pushing history.

---

### I5. [extract.rs](file:///Users/jagjeet/Development/Pilcrow/src/extract.rs) ‚Äî `RequestMode` is not re-exported

[extract.rs:14-18](file:///Users/jagjeet/Development/Pilcrow/src/extract.rs#L14-L18) ‚Äî `RequestMode` is `pub` but not re-exported from [lib.rs](file:///Users/jagjeet/Development/Pilcrow/src/lib.rs). Users who match on [preferred_mode()](file:///Users/jagjeet/Development/Pilcrow/src/extract.rs#84-93) need `pilcrow::extract::RequestMode` instead of `pilcrow::RequestMode`.

---

### I6. No [send](file:///Users/jagjeet/Development/Pilcrow/src/ws.rs#224-236)/[live](file:///Users/jagjeet/Development/Pilcrow/silcrow/index.js#119-123) WebSocket methods in [Silcrow](file:///Users/jagjeet/Development/Pilcrow/src/sse.rs#55-58) API table in [SILCROW.md](file:///Users/jagjeet/Development/Pilcrow/SILCROW.md)

The "API Reference" section has a "Live (SSE)" table but it doesn't mention `Silcrow.send()`, even though it's documented in the body above. The API reference table should include [send(root, data)](file:///Users/jagjeet/Development/Pilcrow/src/ws.rs#224-236) for completeness.

---

## Summary

| Category | Count | Priority |
|---|---|---|
| Bugs | 5 | B1 is high (retarget broken), B3 medium, rest low |
| DRY | 4 | D1 is highest-value (security code duplication) |
| Smells | 4 | S1 is most actionable (long function) |
| Improvements | 6 | I4, I5, I6 are quick wins |
